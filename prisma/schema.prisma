// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int      @id @default(autoincrement())
  name                String   @db.VarChar(255)
  email               String   @unique @db.VarChar(255)
  password            String   @db.VarChar(255)
  role                String   @db.VarChar(50) // admin or brand
  status              Int      @default(1) @db.TinyInt // 1 = active, 0 = inactive
  avatar_url          String?  @db.VarChar(500)
  brand_id            Int? // Link to brand for brand users
  onboarding_complete Int      @default(0) @db.TinyInt // 0 = not complete, 1 = complete
  created_at          DateTime @default(now())
  updated_at          DateTime @updatedAt

  brand            Brand?          @relation(fields: [brand_id], references: [id], onDelete: SetNull)
  assignedTickets  SupportTicket[] @relation("TicketAssignee")
  ticketMessages   TicketMessage[] @relation("TicketMessageSender")

  @@index([brand_id])
  @@index([created_at])
  @@map("users")
}

model Brand {
  id           Int      @id @default(autoincrement())
  name         String   @db.VarChar(255)
  logo_url     String?  @db.VarChar(500)
  status       Int      @default(1) @db.TinyInt // 1 = active, 0 = inactive
  descriptions String   @db.Text
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt

  products Product[]
  users    User[]
  tickets  SupportTicket[]

  @@index([created_at])
  @@map("brands")
}

model Product {
  id         Int      @id @default(autoincrement())
  code       String   @unique @db.VarChar(100)
  metadata   Json // Dynamic JSON containing all product info including images
  status     Int      @default(1) @db.TinyInt // 1 = active, 0 = inactive
  brand_id   Int
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  brand Brand @relation(fields: [brand_id], references: [id], onDelete: Cascade)

  @@index([brand_id])
  @@index([created_at])
  @@map("products")
}

model Tag {
  id             Int      @id @default(autoincrement())
  code           String   @unique @db.VarChar(100)
  product_ids    Json // Array of product IDs stored as JSON
  metadata       Json // Dynamic JSON metadata
  is_stamped     Int      @default(0) @db.TinyInt // 0 = not stamped, 1 = stamped to blockchain
  hash_tx        String?  @db.VarChar(255) // Generated hash from blockchain transaction
  publish_status Int      @default(0) @db.TinyInt // 0 = draft, 1 = published (internal app state)
  chain_status   Int?     @db.TinyInt // Blockchain lifecycle status (0-5: CREATED/DISTRIBUTED/CLAIMED/TRANSFERRED/FLAGGED/REVOKED)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  scans   TagScan[]
  nft     TagNFT?
  tickets SupportTicket[]

  @@index([created_at])
  @@map("tags")
}

model TagScan {
  id             Int      @id @default(autoincrement())
  tag_id         Int
  fingerprint_id String   @db.VarChar(255) // FingerprintJS visitor ID
  ip_address     String   @db.VarChar(45) // IPv4 or IPv6
  user_agent     String   @db.Text
  latitude       Float? // GPS latitude
  longitude      Float? // GPS longitude
  location_name  String?  @db.VarChar(500) // Reverse geocoded location name
  is_claimed     Int      @default(0) @db.TinyInt // 0 = scan only, 1 = claimed
  is_first_hand  Int?     @db.TinyInt // 1 = first hand, 0 = second hand (null = not answered)
  source_info    String?  @db.Text // Where did they get it (for second hand)
  scan_number    Int      @default(1) // Sequential scan number for this tag
  created_at     DateTime @default(now())

  tag Tag @relation(fields: [tag_id], references: [id], onDelete: Cascade)

  @@index([tag_id])
  @@index([fingerprint_id])
  @@map("tag_scans")
}

model TagNFT {
  id               Int      @id @default(autoincrement())
  tag_id           Int      @unique
  token_id         String   @db.VarChar(100) // On-chain token ID
  owner_address    String   @db.VarChar(42) // Wallet address (0x + 40 hex chars)
  image_url        String   @db.VarChar(500) // R2 URL for NFT image
  metadata_url     String   @db.VarChar(500) // R2 URL for metadata JSON
  mint_tx_hash     String?  @db.VarChar(66) // Mint transaction hash
  transfer_tx_hash String?  @db.VarChar(66) // Transfer transaction hash (if different from mint)
  created_at       DateTime @default(now())

  tag Tag @relation(fields: [tag_id], references: [id], onDelete: Cascade)

  @@index([owner_address])
  @@index([created_at])
  @@map("tag_nfts")
}

// ============ Support Ticket System ============

model SupportTicket {
  id             Int       @id @default(autoincrement())
  ticket_number  String    @unique @db.VarChar(20) // e.g. TKT-20251204-ABCD
  tag_id         Int
  brand_id       Int
  wallet_address String    @db.VarChar(42) // NFT owner's wallet
  category       String    @db.VarChar(50) // defect, quality, missing_parts, warranty, other
  subject        String    @db.VarChar(200)
  description    String    @db.Text
  status         String    @default("open") @db.VarChar(20) // open, in_progress, resolved, closed
  priority       String    @default("normal") @db.VarChar(20) // low, normal, high, urgent
  assigned_to    Int? // User ID (brand user or admin)
  resolved_at    DateTime?
  created_at     DateTime  @default(now())
  updated_at     DateTime  @updatedAt

  tag         Tag             @relation(fields: [tag_id], references: [id], onDelete: Cascade)
  brand       Brand           @relation(fields: [brand_id], references: [id], onDelete: Cascade)
  assignee    User?           @relation("TicketAssignee", fields: [assigned_to], references: [id], onDelete: SetNull)
  messages    TicketMessage[]
  attachments TicketAttachment[]

  @@index([brand_id])
  @@index([wallet_address])
  @@index([status])
  @@index([created_at])
  @@map("support_tickets")
}

model TicketMessage {
  id             Int      @id @default(autoincrement())
  ticket_id      Int
  sender_type    String   @db.VarChar(20) // customer, brand, admin
  sender_address String?  @db.VarChar(42) // wallet address if customer
  sender_user_id Int? // user_id if brand/admin
  message        String   @db.Text
  created_at     DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticket_id], references: [id], onDelete: Cascade)
  sender User?         @relation("TicketMessageSender", fields: [sender_user_id], references: [id], onDelete: SetNull)

  @@index([ticket_id])
  @@index([created_at])
  @@map("ticket_messages")
}

model TicketAttachment {
  id         Int      @id @default(autoincrement())
  ticket_id  Int
  file_url   String   @db.VarChar(500)
  file_name  String   @db.VarChar(200)
  file_type  String   @db.VarChar(50) // image/png, image/jpeg, etc.
  file_size  Int // in bytes
  created_at DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticket_id], references: [id], onDelete: Cascade)

  @@index([ticket_id])
  @@map("ticket_attachments")
}
